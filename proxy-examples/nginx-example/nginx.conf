# Make selected environment variables available to worker processes (OpenResty)
env PROMPTQL_ACCESS_TOKEN;
env PROMPTQL_PROJECT_ID;
env PROMPTQL_TOKEN_REFRESH_URL;

events {
    worker_connections 1024;
}

http {
    # Basic settings
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    # MIME types (OpenResty path)
    include /usr/local/openresty/nginx/conf/mime.types;
    default_type application/octet-stream;

    # DNS resolver for Lua cosockets and upstream name resolution
    resolver 1.1.1.1 8.8.8.8 ipv6=off;

    # Trust store for Lua HTTPS (resty.http ssl verification)
    lua_ssl_trusted_certificate /etc/ssl/certs/ca-certificates.crt;
    lua_ssl_verify_depth 5;

    # Sanitize sensitive headers for logging
    map $http_authorization $http_authorization_redacted {
        default "[REDACTED]";
        "" "";
    }
    map $sent_http_authorization $sent_http_authorization_redacted {
        default "[REDACTED]";
        "" "";
    }

    # Custom log formats
    log_format detailed '$remote_addr - $remote_user [$time_local] '
                       '"$request" $status $bytes_sent '
                       '"$http_referer" "$http_user_agent" '
                       'rt=$request_time uct="$upstream_connect_time" '
                       'uht="$upstream_header_time" urt="$upstream_response_time" '
                       'upstream="$upstream_addr" '
                       'auth_header="$sent_http_authorization_redacted"';

    log_format proxy_debug '$remote_addr - [$time_local] "$request" '
                          'status=$status bytes_sent=$bytes_sent '
                          'request_time=$request_time '
                          'upstream_addr=$upstream_addr '
                          'upstream_status=$upstream_status '
                          'upstream_response_time=$upstream_response_time '
                          'sent_auth="$sent_http_authorization_redacted" '
                          'received_auth="$http_authorization_redacted"';

    log_format incoming_requests '$remote_addr [$time_local] IN: "$request" '
                                'headers: auth="$http_authorization_redacted" '
                                'host="$http_host" ua="$http_user_agent"';

    # Logging
    access_log /var/log/nginx/access.log detailed;
    access_log /dev/stdout detailed;
    error_log /var/log/nginx/error.log debug;
    error_log /dev/stderr info;

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 10240;
    gzip_proxied expired no-cache no-store private auth;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/x-javascript
        application/xml+rss
        application/javascript
        application/json;

        # Shared dict for token cache (OpenResty)
        lua_shared_dict token_cache 1m;


    # Rate limiting
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;

    # Upstream PromptQL API
    upstream promptql_api {
        server ${PROMPTQL_API_ENDPOINT};
        keepalive 32;
    }

    server {
        listen 8080;
        server_name localhost;

        # Health check endpoint
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }

        # Proxy all requests to PromptQL API
        location / {
            # Log the original request
            access_log /var/log/nginx/requests.log incoming_requests;

            # Override access log for detailed proxy logging
            access_log /var/log/nginx/proxy.log proxy_debug;
            access_log /dev/stdout proxy_debug;

            # Apply rate limiting
            limit_req zone=api burst=20 nodelay;


                # Inject ddn_headers.Authorization into JSON body via OpenResty Lua
                access_by_lua_block {
                    local http = require "resty.http"
                    local cjson = require "cjson.safe"

                    -- Read env vars exposed via `env` in main context
                    local access_token = os.getenv("PROMPTQL_ACCESS_TOKEN")
                    local project_id = os.getenv("PROMPTQL_PROJECT_ID")
                    local token_refresh_url = os.getenv("PROMPTQL_TOKEN_REFRESH_URL") or "https://auth.pro.hasura.io/ddn/promptql/token"

                    if not access_token or access_token == "" then
                        ngx.log(ngx.ERR, "PROMPTQL_ACCESS_TOKEN environment variable is not set")
                        return ngx.exit(500)
                    end
                    if not project_id or project_id == "" then
                        ngx.log(ngx.ERR, "PROMPTQL_PROJECT_ID environment variable is not set")
                        return ngx.exit(500)
                    end

                    local cache = ngx.shared.token_cache

                    local function fetch_token()
                        local cached = cache:get("promptql_token")
                        if cached then
                            return cached
                        end

                        local httpc = http.new()
                        httpc:set_timeout(5000)
                        local res, err = httpc:request_uri(token_refresh_url, {
                            method = "POST",
                            headers = {
                                ["Authorization"] = "pat " .. access_token,
                                ["x-hasura-project-id"] = project_id,
                                ["Content-Type"] = "application/json",
                            },
                            body = "{}",
                        })
                        if not res then
                            ngx.log(ngx.ERR, "Failed to request token: ", err)
                            return nil, err
                        end
                        if res.status ~= 200 then
                            ngx.log(ngx.ERR, "Failed to fetch token: ", res.status, " ", res.reason, " body: ", res.body)
                            return nil, "HTTP " .. res.status
                        end

                        local data, derr = cjson.decode(res.body)
                        if not data or not data.token then
                            ngx.log(ngx.ERR, "Failed to decode token response: ", derr or "no token in response")
                            return nil, derr or "no token"
                        end

                        cache:set("promptql_token", data.token, 900)
                        return data.token
                    end

                    -- Read and modify JSON request body
                    ngx.req.read_body()
                    local body_data = ngx.req.get_body_data()
                    if not body_data then
                        -- Nothing to inject (e.g., GET or empty body)
                        return
                    end

                    local body_json, perr = cjson.decode(body_data)
                    if not body_json then
                        ngx.log(ngx.ERR, "Request body is not valid JSON: ", perr)
                        return ngx.exit(400)
                    end

                    if type(body_json.ddn_headers) ~= "table" then
                        body_json.ddn_headers = {}
                    end

                    local token, terr = fetch_token()
                    if not token then
                        ngx.log(ngx.ERR, "Could not obtain token: ", terr)
                        return ngx.exit(500)
                    end

                    -- Inject Authorization header for DDN into the body
                    body_json.ddn_headers["x-hasura-ddn-token"] = token
                    body_json.injected_at = ngx.time()

                    local new_body, enc_err = cjson.encode(body_json)
                    if not new_body then
                        ngx.log(ngx.ERR, "Failed to encode modified body: ", enc_err)
                        return ngx.exit(500)
                    end

                    ngx.req.set_body_data(new_body)
                    ngx.req.set_header("Content-Length", #new_body)
                    ngx.req.set_header("Content-Type", "application/json")
                    ngx.log(ngx.INFO, "Injected ddn_headers.Authorization into request body")
                    -- DEBUG: logging forwarded JSON body with token redacted
                    body_json.ddn_headers["x-hasura-ddn-token"] = "[REDACTED]"
                    local __log_str = cjson.encode(body_json)
                    if __log_str then
                        ngx.log(ngx.INFO, "Forwarding body (token redacted): ", __log_str) end
                }

            # Remove any existing Authorization header from client
            proxy_set_header Authorization "";

            # Inject the API key from environment variable
            # This is set via envsubst in the Docker container
            proxy_set_header Authorization "api-key ${PROMPTQL_API_KEY}";

            # Standard proxy headers
            proxy_set_header Host ${PROMPTQL_API_HOST};
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Forwarded-Host $server_name;

            # Handle SSE connections
            proxy_set_header Connection '';
            proxy_http_version 1.1;
            proxy_buffering off;
            proxy_cache off;
            proxy_read_timeout 24h;
            proxy_send_timeout 24h;

            # Forward to PromptQL API
            proxy_pass https://promptql_api;
            proxy_ssl_server_name on;
            proxy_ssl_name ${PROMPTQL_API_HOST};
            proxy_ssl_verify off;

            # Handle connection errors gracefully
            proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
        }
    }
}
